## 最大子序和

##### [leetCode](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

***



# solution

## DP

```
输入：nums[-2,1,-3,4,-1,2,1,-5,4 ]
```

**假设为n个数**

分析：题目要求的是**连续**子数组，且连续子数组的**和为最大**。

​	一开始按照正常思维，我们以左边为界限：逐个选择数列中的数作为开头的数，然后与右边的数组合为序列：

例如：

1. 选定-2为开头，选择组合：-2     -2,1      -2,1,-3     -2,1,-3,4 .....
2. 选定1位开头，选择组合：  1      1,-3      1,-3,4      1,-3,4,-1
3. 以此类推...

​	这样几乎每一次的组合都是一个新的组合，不利于我们用已知推解未知。即找不出**重叠子问题**，那么，我们换一个方向尝试：

以**右边为界限**每次选定一个数作为结尾，以这个数为右边界。

​	参考以下表格：

|            | 存在序列                                    | 最大序列 | max  |
| ---------- | ------------------------------------------- | -------- | ---- |
| 以-2结尾： | **#-2**                                     | -2       | -2   |
| 以1结尾：  | #-2,1            **#1**                     | 1        | 1    |
| 以-3结尾： | #-2,1,-3        **#1,-3**        #-3        | 1,-3     | -2   |
| 以4结尾：  | #-2,1,-3,4     #1,-3,4     #-3,4     **#4** | 4        | 4    |

​	这样，我们每次增加一个数作为右边界的时候，我们只需要把**之前算出的最优子序列和递增数相加的和**与**递增数自身**比较，即可算出新的最优子序列。

- 如果目前的最优子序列和当前递增数相加的和比递增数**大**，那么最优子序列则为当前的子序列+递增数，理解为递增数对当前的子序列有增益。

- 如果目前的最优子序列和当前递增数相加的和比递增数**小**，那么递增数则自身作为下一个最优子序列，可以理解为，抛弃之前的序列，重新以该数作为连续子序列的开头（该子序列个数也有可能为1）。